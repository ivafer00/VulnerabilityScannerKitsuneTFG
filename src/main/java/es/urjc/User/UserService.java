package es.urjc.User;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.context.SecurityContext;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.stereotype.Service;

import javax.persistence.EntityManager;
import javax.persistence.Query;
import javax.transaction.Transactional;
import java.util.Optional;

@Service
public class UserService {

    @Autowired
    protected UserRepository userRep;

    @Autowired
    private EntityManager entityManager;

    public boolean addUser(User user) {

        // Sanity check
        if (user.getUsername().isEmpty()||user.getPasswordHash().isEmpty()) {
            return false;
        }

        userRep.saveAndFlush(user);

        return true;

    }

    public Optional<User> getUser(String username) {

        // Sanity check
        if (username.isEmpty()) {
            return Optional.empty();
        }

        return userRep.findByUsername(username);
    }

    public boolean isValidUser(String username) {

        return getUser(username).isPresent();
    }

    public boolean deleteUser(String username) {

        Optional<User> userByUsername = getUser(username);

        if(userByUsername.isPresent()) {
            userRep.delete(userByUsername.get());
            return true;

        } else {
            return false;

        }
    }

    public boolean changePassword(String username, String newPassword) {

        Optional<User> userByUsername = getUser(username);

        if(userByUsername.isPresent()&&!newPassword.isEmpty()) {
            String newPasswordHash = new BCryptPasswordEncoder().encode(newPassword);
            userByUsername.get().setPasswordHash(newPasswordHash);
            userRep.saveAndFlush(userByUsername.get());
            return true;

        } else {
            return false;

        }
    }

    public boolean changeUsernameShowed(String username, String newUsernameShowed) {

        Optional<User> userByUsername = getUser(username);

        if(userByUsername.isPresent()&&!newUsernameShowed.isEmpty()) {
            userByUsername.get().setUsernameShowed(newUsernameShowed);
            userRep.saveAndFlush(userByUsername.get());
            return true;

        } else {
            return false;

        }
    }

    public boolean isAdminUser(User user) {
        return hasRole("ROLE_ADMIN");
    }

    public boolean hasRole(String role) {
        SecurityContext context = SecurityContextHolder.getContext();
        if (context == null)
            return false;

        Authentication authentication = context.getAuthentication();
        if (authentication == null)
            return false;

        for (GrantedAuthority auth : authentication.getAuthorities()) {
            if (role.equals(auth.getAuthority()))
                return true;
        }

        return false;
    }

    @Transactional
    public String getNumberOfScansPerformed(String username){
        Optional<User> optionalUser = this.getUser(username);
        if(optionalUser.isPresent()){
            User user = optionalUser.get();
            long numberId = user.getNumberOfScansPerformed();
            Query updateScans = this.entityManager.createQuery("UPDATE User u set u.numberOfScansPerformed = u.numberOfScansPerformed + 1 WHERE u.username = :username");
            updateScans.setParameter("username", username);
            updateScans.executeUpdate();
            return String.valueOf(numberId);
        } else return null;
    }
}
