package es.urjc.WebElements;

import java.net.MalformedURLException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import java.util.HashMap;

public class WebSyntaxWrapper {
    /*
     *   This method checks if a URL is absolute or not. A URL is considered absolute if it begins with http:// or https://
     *
     *   @param  String  url
     *
     *   @return true, if it's an absolute URL, otherwise false.
     */
    public static boolean isAbsoluteUrl(String url){
        return url.matches("^(http|https)://.*$");
    }

    /*
     *
     *
     */
    public static String relativeURLToAbsoluteUrl(String currentUrl, String relativeUrl){
        try{
            URL baseUrl = new URL(currentUrl);
            return new URL(baseUrl, relativeUrl).toString();
        } catch (MalformedURLException e) {
            e.printStackTrace();
            return null;
        }
    }

    public static String getProtocol(String url) throws URISyntaxException {
        return new URI(url).getScheme();
    }

    public static String getBaseUrl(String url) throws URISyntaxException {
        return new URI(url).getAuthority();
    }

    /**/
    public static String getUrlFromGETRequest(String getRequest){
        if(getRequest == null) return null;
        try {
            URI uri = new URI(getRequest);
            return new URI(uri.getScheme(),
                    uri.getAuthority(),
                    uri.getPath(),
                    null,
                    null).toString();
        } catch (URISyntaxException e) {
            return null;
        }
    }

    /**/
    public static String getParamsFromGETRequest(String getRequest){
        try {
            return new URI(getRequest).getQuery();
        } catch (URISyntaxException exception){
            return null;
        }
    }

    /**/
    public static HashMap<String,String> decodeParamsString(String params){
        if(params == null) return new HashMap<>();
        HashMap<String, String> map = new HashMap<>();
        String[] paramPairs = params.split("&");
        for (String paramPair: paramPairs) {
            if(!paramPair.startsWith("=")){
                String[] paramSet = paramPair.split("=");
                String paramName = paramSet[0];
                String paramValue = "";
                if(paramSet.length == 2)paramValue = paramSet[1];
                map.put(paramName, paramValue);
            }
        }
        return map;
    }

    /**/
    public static String inferType(String value){
        try {
            Integer.parseInt(value);
            return "number";
        } catch (NumberFormatException exception){
            return "text";
        }
    }

    /*
     *   This method return the value of an expression between quotes or curly braces.
     *   If the first character is a quote, it will check for the next index that contains a quote.
     *   If the first character is an opened curly brace, it will look index by index: if there is another
     *   opened curly brace, it will look for two closed curly braces; otherwise look for a closed curly brace.
     *
     *   @param text The string that contains the expression
     *
     *   @return the string value of the expression, otherwise null.
     */
    public static String parseStringValue(String text){
        if(text==null || text.isEmpty()) return null;
        char firstChar = text.charAt(0);
        if(firstChar == '"' || firstChar == '\''){
            text = text.substring(1);
            return text.substring(0, text.indexOf(firstChar));
        } else if (firstChar == '{'){
            StringBuilder parsedValue = new StringBuilder();
            int counter = 1;
            int iteration = 1;
            while (counter != 0 && iteration < text.length()){
                if(text.charAt(iteration) == firstChar){
                    counter += 1;
                } else if(text.charAt(iteration) == '}'){
                    counter -= 1;
                }

                if(counter != 0){
                    parsedValue.append(text.charAt(iteration));
                }

                iteration++;
            }
            if(counter == 0){
                return parsedValue.toString();
            }
        }
        return null;
    }


}
