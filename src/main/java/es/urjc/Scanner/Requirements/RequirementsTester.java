package es.urjc.Scanner.Requirements;

import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.stream.Collectors;

import es.urjc.Report.Report;
import es.urjc.Report.Static.ContextReport;
import es.urjc.Report.Static.RequirementReport;
import es.urjc.Scanner.ScanningOptions;
import one.util.streamex.EntryStream;
import org.apache.commons.io.FilenameUtils;
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;

public class RequirementsTester {

    private final Map<String, List<String>> filesByExtension;
    private final Map<String, List<String>> javaFilesByAnnotation;
    private final Map<String, List<String>> contentByFilename;
    private ScanningOptions scanningOptions;
    private SseEmitter webCommunicator;

    public RequirementsTester(String projectPath, ScanningOptions scanningOptions){
        this.scanningOptions = scanningOptions;
        this.filesByExtension = this.tree(projectPath);
        this.contentByFilename = this.deleteCommentsFromFiles();
        this.javaFilesByAnnotation = this.mapJavaFilesByAnnotation();
//        this.findTextInDocument("C:\\Users\\ivafe\\TFG COPIA\\DWSProyectOK\\Pokedex\\src\\main\\resources\\application.properties", "server.ssl.key-store");
    }

    public Map<String, List<String>> tree(String path){
        try {
            return Files.find(Paths.get(path),
                            Integer.MAX_VALUE,
                            (filePath, fileAttr) -> fileAttr.isRegularFile())
                    .map(Path::toString)
                    .collect(Collectors.groupingBy(FilenameUtils::getExtension));
        } catch (IOException e) {
            e.printStackTrace();
        }
        return new HashMap<>();
    }

    public String readFile(String path){
        try {
            BufferedReader bufferedReader = new BufferedReader(new FileReader(path));
            StringBuilder content = new StringBuilder();
            String line;
            while ((line = bufferedReader.readLine()) != null){
                content.append(line).append("\n");
            }
            return content.toString();
        } catch (Exception exception){
            return "";
        }
    }

    public Map<String, List<String>> deleteCommentsFromFiles(){
        HashMap<String, List<String>> filesWithoutComment = new HashMap<>();
        for(SupportedFile supportedFile : SupportedFile.values()) {
            List<String> filesToParse = this.filesByExtension.get(supportedFile.getLanguage().toLowerCase());
            for(String filename : filesToParse){
                String parsedContent = supportedFile.deleteCommentFromText(this.readFile(filename));
                if(!parsedContent.isEmpty()){
                    filesWithoutComment.put(filename, Arrays.stream(parsedContent.split("\n")).toList());
                }
            }
        }
        return filesWithoutComment;
    }

    public Map<String, List<String>> mapJavaFilesByAnnotation(){
        List<String> javaFiles = this.filesByExtension.get("java");
        String[] annotations = new String[]{"@Service", "@Controller", "@RestController", "@Entity", "@EnableGlobalMethodSecurity"};
        HashMap<String, List<String>> map = new HashMap<>();

        for(String annotation : annotations){
            List<String> matchCondition = new ArrayList<>();
            for(String javaFile: javaFiles){
                if(findTextInDocument(javaFile, annotation)){
                    matchCondition.add(javaFile);
                }
            }
            map.put(annotation, matchCondition);
        }
        return map;
    }

    public boolean findTextInDocument(String document, String textToSearch){
        return this.contentByFilename.get(document).stream().anyMatch(line -> line.matches(textToSearch));
    }

    public List<LineOfCode> findLinesOfCodeThatContainsText(String document, String textToSearch){
        List<String> linesStream = this.contentByFilename.get(document);
        return EntryStream.of(linesStream).mapKeyValue(LineOfCode::new).filter(lineOfCode -> lineOfCode.contains(textToSearch)).toList();
    }

    public List<LineOfCode> findLinesOfCodeThatMatchesText(String document, String textToSearch){
        List<String> linesStream = this.contentByFilename.get(document);
        return EntryStream.of(linesStream).mapKeyValue(LineOfCode::new).filter(lineOfCode -> lineOfCode.matches(textToSearch)).toList();
    }

    public void checkForAPIMethods(){
        HashMap<String, Boolean> methodValidation = new HashMap<>();
        String[] methods = new String[]{"@GetMapping", "@PostMapping", "@PutMapping", "@DeleteMapping", "@PatchMapping"};
        for(String method : methods){
            methodValidation.put(method, false);
        }

        List<String> restControllerFiles = this.javaFilesByAnnotation.get("@RestController");
        for(String file : restControllerFiles){
            ArrayList<LineOfCode> annotationLines = new ArrayList<>();

            for(String method : methods){
                List<LineOfCode> localList = this.findLinesOfCodeThatContainsText(file, method);
                if(localList.size() != 0){
                    methodValidation.put(method, true);
                    annotationLines.addAll(localList);
                }
            }
            if(annotationLines.size() > 0){
                for(LineOfCode lineOfCode : annotationLines){
                    this.sendReport(new ContextReport("APIMethods", file, lineOfCode.getContext(this.contentByFilename.get(file), 0, 5)));
                }
            }

        }
        this.sendReport(new RequirementReport("APIMethods", !methodValidation.containsValue(false)));

    }

    public void searchForTemplateInjection(){
        List<String> htmlTemplates = this.filesByExtension.get("html");
        List<String> posibleVulnerableTemplates = new ArrayList<>();
        for(String htmlTemplate: htmlTemplates){
            List<LineOfCode> posibleVulnerableLines = this.findLinesOfCodeThatMatchesText(htmlTemplate, ".*\\{\\{\\{.*}}}.*");  // Mustache
            posibleVulnerableLines.addAll(this.findLinesOfCodeThatMatchesText(htmlTemplate, ".*__.*__.*"));                     // Thymeleaf
            if(!posibleVulnerableLines.isEmpty()){
                posibleVulnerableTemplates.add(htmlTemplate);
                for (LineOfCode lineOfCode : posibleVulnerableLines){
                    this.sendReport(new ContextReport("TemplateInjection", htmlTemplate, lineOfCode.getContext(this.contentByFilename.get(htmlTemplate), 5, 5)));
                }
            }
        }
        this.sendReport(new RequirementReport("TemplateInjection", posibleVulnerableTemplates.size() > 0));
    }

    public void searchForDataBaseCommunication(){
        List<String> javaFiles = this.filesByExtension.get("java");
        boolean passed = false;
        for(String javaFile : javaFiles){
            List<LineOfCode> entityManagerPresent = this.findLinesOfCodeThatContainsText(javaFile,"EntityManager ");
            if(!entityManagerPresent.isEmpty()){
                for(LineOfCode definitionLine : entityManagerPresent){
                    String variableName = definitionLine.getContent().split("EntityManager ")[1].replaceAll(" ", "");
                    if(variableName.contains(";")) variableName = variableName.split(";")[0];
                    if(variableName.contains("=")) variableName = variableName.split("=")[0];
                    List<LineOfCode> entityManagerCalls = this.findLinesOfCodeThatContainsText(javaFile,variableName);
                    for(LineOfCode lineOfCode : entityManagerCalls){
                        if(lineOfCode.contains(variableName + ".createQuery(") || lineOfCode.contains(variableName + ".executeUpdate(")){
                            passed = true;
                            this.sendReport(new ContextReport("DataBaseCommunication", javaFile, lineOfCode.getContext(this.contentByFilename.get(javaFile), 5, 5)));
                        }
                    }
                }
            }
        }
        this.sendReport(new RequirementReport("DataBaseCommunication", passed));
    }

    public void searchForEntityRelations(){
        List<String> entities = this.javaFilesByAnnotation.get("@Entity");
        String[] relationAnnotations = new String[]{"@OneToMany", "@ManyToOne", "@ManyToMany"};
        int numberOfEntitiesRelated = 0;
        for(String entity : entities){
            List<LineOfCode> lineOfCodes = new ArrayList<>();
            for(String relation : relationAnnotations){
                lineOfCodes.addAll(this.findLinesOfCodeThatContainsText(entity, relation));
            }

            for (LineOfCode lineOfCode : lineOfCodes){
                numberOfEntitiesRelated += 1;
                this.sendReport(new ContextReport("EntityRelations", entity, lineOfCode.getContext(this.contentByFilename.get(entity), 5, 5)));
            }
        }
        this.sendReport(new RequirementReport("EntityRelations", numberOfEntitiesRelated >= 1));
    }

    public void doScan(){
        if(this.scanningOptions.getAllAPIMethods()) this.checkForAPIMethods();
        if(this.scanningOptions.getPossibleTemplateInjection()) this.searchForTemplateInjection();
        if(this.scanningOptions.getEntityRelations()) this.searchForEntityRelations();
        if(this.scanningOptions.getDatabaseCommunication()) this.searchForDataBaseCommunication();
    }

    public void setWebCommunicator(SseEmitter webCommunicator) {
        this.webCommunicator = webCommunicator;
    }

    public void sendReport(Report report){
        try {
            this.webCommunicator.send(report.emit());
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) {
//        RequirementsTester requirementsTester = new RequirementsTester("C:\\Users\\ivafe\\TFG COPIA\\DWSProyectOK\\Pokedex\\src", new ScanningOptions());
//        requirementsTester.doScan();
    }
}
