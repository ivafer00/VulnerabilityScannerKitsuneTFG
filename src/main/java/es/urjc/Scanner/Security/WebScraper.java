package es.urjc.Scanner.Security;

import es.urjc.Report.Report;
import es.urjc.Report.Vulnerabilities.FormBased.Injection.XSS.StoredXSSReport;
import es.urjc.Report.WebInfo.FormReport;
import es.urjc.Report.WebInfo.UrlRelationReport;
import es.urjc.Vulnerabilities.FormBased.Injection.XSS.XSSInjection;
import es.urjc.Vulnerabilities.ImproperErrorHandling.ImproperErrorHandling;
import es.urjc.WebElements.*;
import es.urjc.WebElements.Form.Form;
import org.openqa.selenium.*;
import org.openqa.selenium.NoSuchElementException;
import org.openqa.selenium.chrome.ChromeDriver;
import org.openqa.selenium.chrome.ChromeOptions;
import org.openqa.selenium.devtools.DevTools;
import org.openqa.selenium.devtools.v101.fetch.Fetch;
import org.openqa.selenium.devtools.v101.network.model.ErrorReason;
import org.openqa.selenium.logging.LogEntry;
import org.openqa.selenium.logging.LogType;
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;

import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.*;

public class WebScraper {

    private String id;

    private final WebDriver driver;
    private final DevTools devTools;

    private SseEmitter webCommunicator;
    private boolean communicateUrlRelation;
    private boolean communicateForm;

    private String baseUrl;
    private String protocol;
    private String initUrl;

    private Boolean scanAll;

    private final HashSet<String> urlsVisited;
    private final HashSet<String> urlsToVisit;
    private HashSet<UrlRelation> applicationsMap;

    private final HashSet<Form> unauthForms;
    private boolean isAuthenticated;
    private final HashSet<Form> authForms = new HashSet<>();
    private PriorityQueue<Form> loginForms;

    public WebScraper(String initialUrl, Boolean scanAll){

        // Set the location of Chrome WebDriver
        System.setProperty("webdriver.chrome.driver", "./chromedriver.exe");
        ChromeOptions options = new ChromeOptions();
        //TODO: Remove in final version to make it trasparent to the user
        //TODO: Manage http without SSL Certificate
        //	    options.addArguments("--headless", "--window-size=1920,1200","--ignore-certificate-errors");
        options.addArguments("--ignore-certificate-errors");
//        options.addArguments("--headless");
        options.setCapability("ACCEPT_SSL_CERTS", true);
        options.setCapability("ACCEPT_INSECURE_CERTS", true);

        this.driver = new ChromeDriver(options);
        this.devTools = ((ChromeDriver) driver).getDevTools();
        this.devTools.createSession();

        this.urlsVisited = new HashSet<>();
        this.urlsToVisit = new HashSet<>();
        this.unauthForms = new HashSet<>();
        this.isAuthenticated = false;
        this.applicationsMap = new HashSet<>();
        this.scanAll = scanAll;

        try {
            URI uri = new URI(initialUrl);
            this.baseUrl = uri.getAuthority();
            this.protocol = uri.getScheme() + "://";
            this.initUrl = initialUrl;
        } catch (URISyntaxException e) {
            e.printStackTrace();
        }

        this.addUrlToVisit(initialUrl);
    }

    public String getId(){return this.id;}
    public void setId(String id){
        this.id = id;
    }

    public String getProtocol() {
        return protocol;
    }

    public void setAuthenticated(boolean authenticated) {
        isAuthenticated = authenticated;
    }

    public void setCommunicateUrlRelation(boolean communicateUrlRelation) {
        this.communicateUrlRelation = communicateUrlRelation;
    }

    public void setCommunicateForm(boolean communicateForm) {
        this.communicateForm = communicateForm;
    }

    public void setWebCommunicator(SseEmitter webCommunicator){
        this.webCommunicator = webCommunicator;
    }

    public void sendReport(Report report){
        try {
            this.webCommunicator.send(report.emit());
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    /*
    *   Get the URL that is displayed on the ChromeDriver.
    *   This method handles alerts opened by JavaScript, otherwise the execution would be interrupted.
    *
    *   @return the current url
    */
    public String getCurrentUrl(){
        String url;
        try {
            url = this.driver.getCurrentUrl();
            return WebSyntaxWrapper.getUrlFromGETRequest(url);
        } catch(UnhandledAlertException alert) {
//            this.manageAlert(alert.getAlertText());
            return this.driver.getCurrentUrl();
        }
    }

    /*
    *   Add a URL to the set of URLs that will be visited.
    *   This method checks that the provided URL wasn't visited before.
    *
    *   @param url the url that is going to be enqueued
    */
    public void addUrlToVisit(String url) {
        if(!this.urlsVisited.contains(url)) {
            this.urlsToVisit.add(url);
        }
    }

    /*
    *   Display a URL from the set of URLs to visit.
    *   This method checks that the set is not empty and handles alerts that may be opened by JavaScript.
    *   If an alert is present, the manageAlert method is called.
    *
    *   @return the new current URL or "visited" (if it's in the set urlsVisited) or null (if the set urlsToVisit is empty).
    */
    public String visitUrl() {
        if(!this.urlsToVisit.isEmpty()) {

            String urlToVisit = this.urlsToVisit.iterator().next();
            this.urlsToVisit.remove(urlToVisit);

            if(!this.urlsVisited.contains(urlToVisit)) {

                try {
                    this.driver.get(urlToVisit);

                    if(!this.communicateForm){
                        List<String> xssLogs = XSSInjection.isXSSPresent(this.getLogs(), this.getId(), urlToVisit);
                        if(!xssLogs.isEmpty()){
                            HashMap<String, StoredXSSReport> reports = new HashMap<>();
                            String pageSource = this.getPageSource();
                            for (String xssLog: xssLogs) {
                                String formId = xssLog.split("-")[2];
                                String input = xssLog.split("-")[3];
                                String payloadId = xssLog.split("-")[4];
                                if(!reports.containsKey(formId + payloadId)){
                                    StoredXSSReport report = new StoredXSSReport();
                                    report.setFormId(formId);
                                    report.addVulnerableInput(input);
                                    report.setPayloadId(payloadId);
                                    report.addResponse(pageSource);
                                    reports.put(formId + payloadId, report);
                                } else {
                                    StoredXSSReport report = reports.get(formId + payloadId);
                                    report.addVulnerableInput(input);
                                    reports.put(formId + payloadId, report);
                                }
                            }
                            for(StoredXSSReport report : reports.values()){
                                this.sendReport(report);
                            }
                        }
                    }
                    Alert alert = driver.switchTo().alert();
                    if (alert != null){
//                        this.manageAlert(alert.getText());
                        alert.accept();
                    }
                } catch (UnhandledAlertException alert) {
//                    this.manageAlert(alert.getAlertText());
                } catch (NoAlertPresentException ignored){

                }
                this.urlsVisited.add(urlToVisit);
                return urlToVisit;
            } else {
                return "visited";
            }
        }

        return null;
    }

    /*
    *   Clear all information about the URLs (mapping, visited, toVisit).
    *   Then, add the url that is displayed on the ChromeDriver.
    */
    public void resetUrls(){
        this.applicationsMap.clear();
        this.urlsToVisit.clear();
        this.urlsVisited.clear();
        this.urlsToVisit.add(this.initUrl);
    }

    /*
    *   Send an UrlRelation object to the client via SSE.
    *
    *   @param urlRelation the urlRelation object
    */
    public void addUrlRelation(UrlRelation urlRelation){
        boolean added = this.applicationsMap.add(urlRelation);
        if(this.communicateUrlRelation && added) this.sendReport(new UrlRelationReport(urlRelation, this.isAuthenticated));
//        if(this.communicateUrlRelation) this.sendReport(new UrlRelationReport(urlRelation, this.isAuthenticated));

    }

    /*
    *   Call addUrlRelation with elements inside a collection.
    *
    *   @param urlRelations the collection of UrlRelation objects.
    */
    public void addUrlRelations(Collection<UrlRelation> urlRelations){
        if(this.communicateUrlRelation) {
            for (UrlRelation urlRelation : urlRelations) {
                this.addUrlRelation(urlRelation);
            }
        }
//        } else {
//            this.applicationsMap.addAll(urlRelations);
//        }
    }

    /*
    *   Save a Form object according to the authentication status. Then, send a report to the client via SSE.
    *
    *   @param form the form object.
    */
    public void addForm(Form form){
        boolean added;
        if(!this.isAuthenticated){
            form.setId(String.valueOf(this.unauthForms.size()));
            added = this.unauthForms.add(form);
        } else {
            form.setId(String.valueOf(this.unauthForms.size() + this.authForms.size()));
            added = this.authForms.add(form);
        }

        if(this.communicateForm && added) this.sendReport(new FormReport(form, this.isAuthenticated));
    }

    /*
    *   Clear all the forms collected by the Scraper.
    */
    public void cleanForms(){
        this.unauthForms.clear();
    }

    /*
    *   Find a list of web elements from the HTML that have a certain tag.
    *
    *   @param tagName the name of the tag that should be searched for.
    *
    *   @return the list of web elements that match the conditions.
    */
    public ArrayList<WebElement> findElementsByTagName(String tagName){
        try {
            return new ArrayList<>(this.driver.findElements(By.tagName(tagName)));
        } catch (NoSuchElementException exception){

            return new ArrayList<>();
        }
    }

    public ArrayList<WebElement> findElementsByClassName(String tagName){
        try {
            return new ArrayList<>(this.driver.findElements(By.className(tagName)));
        } catch (NoSuchElementException exception){

            return new ArrayList<>();
        }
    }

    /*
    *   Check if an url is inside the domain of this WebScraper.
    *
    *   @param url the url to be checked
    *
    *   @return True, if the url is inside the domain, otherwise, False.
    */
    public Boolean isInsideDomain(String url){
        return url.matches("^(http|https)://" + this.baseUrl + ".*$");
    }

    /*
    *   Return the source code of the current URL.
    *
    *   @return the source code
    */
    public String getPageSource(){ return this.driver.getPageSource(); }

    /*
    *   Start scraping the target application.
    */
    public void scrap(){
        String visit = this.visitUrl();

        if(visit != null){

            if(visit.equals("visited")) this.scrap();   // Check if the URL was visited before

            String realUrl = this.getCurrentUrl();  // Check if a redirect was performed
            if(!realUrl.equals(visit)){
                this.addUrlRelation(new UrlRelation(visit, realUrl, "redirect"));
                if(this.urlsVisited.contains(realUrl)) this.scrap();
            }

            if(this.isInsideDomain(realUrl)){ // Search for links and redirections
                if(this.scanAll){
                    this.addUrlRelations(WebScrapingTechniques.detectHTMLURLRelations(this, "a", "href"));
                    this.addUrlRelations(WebScrapingTechniques.detectHTMLURLRelations(this, "iframe", "src"));
                    this.addUrlRelations(WebScrapingTechniques.detectJSURLRelation(this));
                }
                if(this.communicateForm) WebScrapingTechniques.detectForms(this);
            }
            this.scrap();
        } else {
            this.autodetectLoginForm("");
//            System.out.println(this.loginForms);
        }

    }

    public String getBaseUrl() {
        return baseUrl;
    }


    /*
    *   Capture all requests that will be sent as a result of submitting a form. This method will be waiting until the
    *   destination URL matches with the form's submit URL. After this condition is met, check for any variation in
    *   request params and save the form.
    *
    *   @param form the form object that will be submitted.
    */
    public void captureNetworkRequests(Form form){

        this.devTools.send(Fetch.enable(Optional.empty(), Optional.empty()));
        this.devTools.addListener(Fetch.requestPaused(), requestPaused -> {
            if(form.isSameForm(WebSyntaxWrapper.getUrlFromGETRequest(requestPaused.getRequest().getUrl()), requestPaused.getRequest().getMethod())) {

                if(requestPaused.getRequest().getMethod().equals("GET")){
                    form.updateParameters(WebSyntaxWrapper.getParamsFromGETRequest(requestPaused.getRequest().getUrl()), "application/x-www-form-urlencoded");
                } else {
                    if(requestPaused.getRequest().getPostData().isPresent()){
                        form.updateParameters(requestPaused.getRequest().getPostData().get(), (String) requestPaused.getRequest().getHeaders().getOrDefault("Content-Type", "malformed"));
                    }
                }
                form.setHeaders(requestPaused.getRequest().getHeaders());

                this.addForm(form);

                devTools.send(Fetch.failRequest(requestPaused.getRequestId(), ErrorReason.ABORTED));
            }
        });

    }

    /*
    *   Remove active listeners on ChromeDevTools session.
    */
    public void stopCapturingRequest(){
        this.devTools.clearListeners();
    }

    /*
    *   Parse the payload with WebScraper id.
    *
    *   @param payload string to be parsed.
    *
    *   @return the parsed payload.
    */
    public String parsePayload(String payload){
        return payload.replaceAll("#scanner_id#", this.id);
//        return resultPayload.replaceAll("#server_id#", this.xssDetectionPath);
    }

    /*
    *   Execute an XMLHttpRequest string inside the chromedriver's console.
    *
    *   @param xhrPayload the request to execute.
    *
    *   @return a ServerResponse object mapping the response.
    */
    public ServerResponse sendXHR(String xhrPayload){
        String response = ((JavascriptExecutor) this.driver).executeAsyncScript(xhrPayload).toString();
        return new ServerResponse(xhrPayload, response);
    }

    /*
    *   Use data scheme to visualize an html content.
    *
    *   @param html a base64 string containing HTML text.
    */
    public void visualizeHTMLContent(String html){
        this.driver.get("data:text/html;base64," + Base64.getEncoder().encodeToString(html.getBytes()));
    }

    public HashSet<Form> getUnauthForms() {
        return unauthForms;
    }

    public HashSet<Form> getAuthForms() { return authForms; }

    /*
    *   Search inside the collected forms, looking for all possible login forms. A priorityqueue is filled with all candidates.
    *
    *   @param loginUrl, if any provided.
    */
    public void autodetectLoginForm(String loginUrl){
        PriorityQueue<Form> candidates = new PriorityQueue<>(this.unauthForms.size(), Comparator.comparingInt(o -> o.isValidLoginForm(loginUrl)));
        for(Form form: this.unauthForms){
            if(form.isValidLoginForm(loginUrl) != 0) candidates.add(form);
        }
        if(!candidates.isEmpty()){
            this.loginForms = candidates;
        }
    }

    /*
    *   Try authentication on the web app. This method search for a valid login form inside the priorityqueue which was
    *   filled by autodetectLoginForm method. A login form is considered as valid if the response of a random login
    *   isn't equal to the response with the credentials provided.
    *
    *   @param username the username value
    *   @param password the password value
    *
    *   @return true, if the login was successful. Otherwise, false.
    */
    public boolean tryAuthentication(String username, String password){
        if(!isInsideDomain(this.getCurrentUrl())){
            try {
                this.driver.get(this.initUrl);
            } catch (UnhandledAlertException alert) {
//                this.manageAlert(alert.getAlertText());
            }
        }
        boolean found = false;
        while (!found && !this.loginForms.isEmpty()){
            Form form = this.loginForms.peek();
            form.fillInputValuesByPriority();

            form.setUsername(ImproperErrorHandling.randomAlphanumericString());
            form.setPassword(ImproperErrorHandling.randomAlphanumericString());
            String falseLogin = form.getXHR();
            ServerResponse falseResponse = this.sendXHR(falseLogin);

            form.setUsername(username);
            form.setPassword(password);

            String trueLogin = form.getXHR();
            ServerResponse trueResponse = this.sendXHR(trueLogin);

            if(trueResponse.isValidResponse() && !trueResponse.getResponseText().equals(falseResponse.getResponseText())){
                found = true;
                this.initUrl = trueResponse.getResponseURL();
            } else {
                this.loginForms.poll();
            }
        }
        return found;
    }

    /*
    *   Get error logs displayed on the current console.
    *
    *   @return a list with all error logs.
    */
    public List<LogEntry> getLogs(){
        return driver.manage().logs().get(LogType.BROWSER).getAll();
    }

    /*
    *   Execute a JavaScript code in the console.
    */
    public void executeScript(String script){
        ((JavascriptExecutor) this.driver).executeScript(script);
    }

    /*
    *   Return to the beginning.
    */
    public void visitInitUrl(){
        try {
            this.driver.get(this.initUrl);
        } catch (Exception e){
            e.printStackTrace();
        }
    }

    public void visitUrl(String url){
        try {
            this.driver.get(url);
        } catch (Exception e){
            e.printStackTrace();
        }
    }

    public void killDriver(){
        this.driver.quit();
    }
}
