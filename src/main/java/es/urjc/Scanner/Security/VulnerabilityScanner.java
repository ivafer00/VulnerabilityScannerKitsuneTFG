package es.urjc.Scanner.Security;

import es.urjc.Report.Vulnerabilities.ImproperErrorHandling.ImproperErrorHandlingReport;
import es.urjc.Report.Vulnerabilities.NoSecureChannel.NoSecureChannelReport;
import es.urjc.Report.WebInfo.ResponseStatusReport;
import es.urjc.Scanner.ScanningOptions;
import es.urjc.Vulnerabilities.FormBased.CSRF.CSRF;
import es.urjc.Vulnerabilities.FormBased.FormBasedVulnerability;
import es.urjc.Vulnerabilities.ImproperErrorHandling.ImproperErrorHandling;
import es.urjc.Vulnerabilities.NoSecureChannel.NoSecureChannel;
import es.urjc.WebElements.Form.FillStrategies.FillStrategy;
import es.urjc.WebElements.Form.Form;
import es.urjc.Report.Report;
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;

import java.io.IOException;
import java.util.*;

public class VulnerabilityScanner {

    private String id;
    private final WebScraper webScraper;
    private SseEmitter webCommunicator;
    private final ScanningOptions scanningOptions;

    public VulnerabilityScanner(String url, ScanningOptions scanningOptions){
        this.webScraper = new WebScraper(url, scanningOptions.getScrapping());
        this.scanningOptions = scanningOptions;
    }

    public void setId(String id) {
        this.webScraper.setId(id);
        this.id = id;
    }

    public void setWebCommunicator(SseEmitter webCommunicator) {

        this.webCommunicator = webCommunicator;
        this.webScraper.setWebCommunicator(webCommunicator);
    }

    public void doScan(){
//        this.closeConnection();

        this.webScraper.setCommunicateForm(true);
        this.webScraper.setCommunicateUrlRelation(true);
//
        if(this.scanningOptions.getApiExploration()) WebScrapingTechniques.parseSwaggerInformation(this.webScraper);
        this.webScraper.scrap();
        this.sendProgressEvent("Unauth Scraping");

        this.attemptVulnerabilities(false);
        this.sendProgressEvent("Exploiting");

        this.webScraper.resetUrls();
        this.webScraper.setCommunicateForm(false);
        this.webScraper.setCommunicateUrlRelation(false);

        this.webScraper.scrap();
        this.sendProgressEvent("Scan for stored vulns");

        if(this.scanningOptions.hasCredentials()){
            boolean authenticationStatus = this.webScraper.tryAuthentication(this.scanningOptions.getUsername(), this.scanningOptions.getPassword());
            if(authenticationStatus){
                this.webScraper.setAuthenticated(true);
                this.webScraper.resetUrls();
                this.webScraper.setCommunicateForm(true);
                this.webScraper.setCommunicateUrlRelation(true);

                this.webScraper.scrap();
                this.sendProgressEvent("Auth Scraping");

                this.attemptVulnerabilities(true);

                this.webScraper.resetUrls();
                this.webScraper.setCommunicateForm(false);
                this.webScraper.setCommunicateUrlRelation(false);

                this.webScraper.scrap();
                this.sendProgressEvent("Authenticated");
            }
        }

        this.closeConnection();
    }

    public HashSet<Form> getForms(boolean isAuthenticated){
        if(isAuthenticated){
            return this.webScraper.getAuthForms();
        } else {
            return this.webScraper.getUnauthForms();
        }
    }

    public void attemptVulnerabilities(boolean isAuthenticated){

        if(this.scanningOptions.getXssScan()){
            List<FormBasedVulnerability> xssInjections = new ArrayList<>(this.scanningOptions.getXssIdPayloads());
            this.sendResponseStatusReport(this.attemptVulnerabilityInForms(this.getForms(isAuthenticated), xssInjections), "XSS");
        }

        if(this.scanningOptions.getSqlInjectionScan()){
            ArrayList<FormBasedVulnerability> sqlInjections = new ArrayList<>(this.scanningOptions.getErrorBasedSqlInjectionIdPayloads());
            sqlInjections.addAll(this.scanningOptions.getBooleanBasedSQLinjectionIdPayloads());
            sqlInjections.addAll(this.scanningOptions.getTimeBasedSqlInjectionIdPayloads());
            this.sendResponseStatusReport(this.attemptVulnerabilityInForms(this.getForms(isAuthenticated), sqlInjections), "SQLi");
        }

        if(this.scanningOptions.getCsrfScan()){
            CSRF csrf = new CSRF();
            List<FormBasedVulnerability> csrfVerification = new ArrayList<>();
            csrfVerification.add(csrf);
            this.attemptVulnerabilityInForms(this.getForms(isAuthenticated), csrfVerification);
        }

        if(!isAuthenticated){
            if(this.scanningOptions.getNoSecureChannel()){
                NoSecureChannel noSecureChannel = new NoSecureChannel();
                NoSecureChannelReport noSecureChannelReport = noSecureChannel.detect(this.webScraper);
                if(noSecureChannelReport != null) this.sendReport(noSecureChannelReport);
            }

            if(this.scanningOptions.getImproperErrorHandling()){
                ImproperErrorHandling improperErrorHandling = new ImproperErrorHandling();
                ImproperErrorHandlingReport improperErrorHandlingReport = improperErrorHandling.detect(this.webScraper);
                if(improperErrorHandlingReport != null) this.sendReport(improperErrorHandlingReport);
            }
        }
    }

    public ArrayList<Form> attemptVulnerabilityInForms(HashSet<Form> forms, List<FormBasedVulnerability> injections){
        ArrayList<Form> parsedForms = new ArrayList<>();
        for (Form form: forms) {
            if(!form.isLogoutForm()){
                Report report = null;
                Iterator<FormBasedVulnerability> injectionIterator = injections.iterator();
                while (report == null && injectionIterator.hasNext()){
                    FormBasedVulnerability injection = injectionIterator.next();
                    FillStrategy strategy = injection.getFillStrategy(form);
                    while (report == null && strategy.hasNextStep()){
                        strategy.nextStep(form);
                        report = injection.detect(this.webScraper, form);
                    }
                    if(report != null) {
                        this.sendReport(report);
                    }
                }
                parsedForms.add(form);
            }
        }

        return parsedForms;
    }

    public void sendResponseStatusReport(ArrayList<Form> forms, String vulnerabilityName){
        for(Form form : forms){
            this.sendReport(new ResponseStatusReport(form, vulnerabilityName));
        }
    }

    public void sendReport(Report report){
        try {
            this.webCommunicator.send(report.emit());
        } catch (IOException exception){
            exception.printStackTrace();
        }
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        VulnerabilityScanner that = (VulnerabilityScanner) o;
        return Objects.equals(id, that.id);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id);
    }

    public void closeConnection(){
        this.webScraper.killDriver();
        this.sendProgressEvent("Finish");
        this.webCommunicator.complete();

    }

    public void sendProgressEvent(String data){
        try {
            this.webCommunicator.send(SseEmitter.event().
                    id(String.valueOf(System.currentTimeMillis()))
                    .name("Progress")
                    .data(data));
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
