package es.urjc.Vulnerabilities.FormBased.CSRF;

import es.urjc.Report.Vulnerabilities.FormBased.CSRF.CSRFReport;
import es.urjc.Scanner.Security.WebScraper;
import es.urjc.Vulnerabilities.FormBased.FormBasedVulnerability;
import es.urjc.WebElements.Form.FillStrategies.ClearAllCSRFTokens;
import es.urjc.WebElements.Form.FillStrategies.FillStrategy;
import es.urjc.WebElements.Form.Form;
import es.urjc.WebElements.ServerResponse;

public class CSRF implements FormBasedVulnerability {


    @Override
    public FillStrategy getFillStrategy(Form form) {
        return new ClearAllCSRFTokens(form);
    }

    public CSRFReport detect(WebScraper webScraper, Form form){
        CSRFReport report = new CSRFReport();
        report.setFormId(form.getId());

        if(form.haveAPossibleCSRFToken() || CSRF.checkForCustomRequestHeader(form)){
            String xmlHttpRequest = form.getXHR();
            ServerResponse response = webScraper.sendXHR(xmlHttpRequest);
            if(!response.isValidResponse()){
                return null;
            }
            report.addRequest(response.getRequest());
            report.addResponse(response.getResponseText());
        }

        return  report;
    }

    public static boolean checkForCustomRequestHeader(Form form){
        String[] customRequestHeaders = new String[]{"csrf-token", "x-csrf-token", "xsrf-token",
                                                    "x-xsrf-token", "csrfp-token", "anti-csrf-token",
                                                    "x-csrf-header", "x-xsrf-header", "x-csrf-protection"};

        for(String header: customRequestHeaders){
            if(form.containsHeader(header)) return true;
        }

        return false;
    }
}
